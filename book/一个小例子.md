% çŒœæ•°å­—æ¸¸æˆ

æœ¬ç« æˆ‘ä»¬å°è¯•ç”¨Rustå®ç°ç»å…¸çš„çŒœæ•°å­—æ¸¸æˆã€‚ç¨‹åºçš„åŸºæœ¬æµç¨‹æ˜¯ï¼š
1ï¼‰ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ï¼›
2ï¼‰æç¤ºç©å®¶è¾“å…¥æ•°å­—ï¼›
3ï¼‰è‹¥ç©å®¶çŒœä¸­æ•°å­—åˆ™ç¨‹åºé€€å‡ºï¼›
4ï¼‰æç¤ºç©å®¶æ•°å­—çŒœçš„è¿‡å¤§æˆ–è¿‡å°ï¼Œç„¶åå›åˆ°æ­¥éª¤2ï¼‰ï¼›

åœ¨å®ç°æœ¬æ¸¸æˆçš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä¼šç»§ç»­æ·±å…¥å­¦ä¹ Rustã€‚ä»ä¸‹ä¸€ç« å¼€å§‹ï¼Œæˆ‘ä»¬ä¼šä»åŸºæœ¬è¯­æ³•å’Œ
è¯­ä¹‰å¼€å§‹è¾ƒä¸ºç³»ç»Ÿçš„å­¦ä¹ Rustè¯­è¨€ã€‚

# åˆ›å»ºå·¥ç¨‹

ä¹‹å‰æˆ‘ä»¬å·²ç»å­¦ä¹ äº†å¦‚ä½•åˆ›å»ºæ–°çš„å·¥ç¨‹ï¼Œä¸‹é¢ç›´æ¥ç»™å‡ºå‘½ä»¤ï¼š

```bash
$ cd ~/projects
$ cargo new guessing_game --bin
$ cd guessing_game
```

æ£€æŸ¥ç”Ÿæˆçš„`Cargo.toml`æ–‡ä»¶ï¼š

```toml
[package]

name = "guessing_game"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
```

Cargoæ˜¯æ ¹æ®å¼€å‘ç¯å¢ƒè‡ªåŠ¨ç”Ÿæˆçš„é…ç½®ï¼Œå¼€å‘è€…å¯ä»¥éšæ—¶è¿›è¡Œè°ƒæ•´ã€‚

# å¤„ç†ç©å®¶è¾“å…¥çš„æ•°å­—

ä¸‹é¢æˆ‘ä»¬éœ€è¦åœ¨mainå‡½æ•°ä¸­å¤„ç†ç©å®¶è¾“å…¥çš„æ•°å­—ï¼š

```rust
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```

æˆ‘ä»¬é€è¡Œåˆ†æä¸Šé¢çš„ä»£ç ï¼š

```rust
use std::io;
```

è¿™ä¸€è¡Œä»£ç çš„ç›®çš„æ˜¯åŠ è½½æ ‡å‡†åº“ä¸­çš„`io`å­åº“ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦å¤„ç†ç©å®¶çš„è¾“å…¥ï¼Œå¹¶ä¸”å°†ç»“æœ
ä½œä¸ºè¾“å‡ºã€‚Rusté»˜è®¤ä¼šå°†æ ‡å‡†åº“ä¸­å±äº[`prelude`][prelude]çš„éƒ¨åˆ†åŠ è½½åˆ°ç¨‹åºä¸­ã€‚
`prelude`åº“çš„ä½œç”¨æ˜¯å°†å…±äº«åº“ä¸­å¸¸ç”¨çš„ç»„ä»¶å°è£…åˆ°ä¸€èµ·ä¾¿äºç¨‹åºå¼€å‘ã€‚`io`åº“é‡ŒåŒæ ·ä¹Ÿæœ‰ä¸€
ä¸ª[`preludeåº“`][ioprelude]ï¼Œç„¶è€Œéœ€è¦æ³¨æ„çš„æ˜¯è¿™ä¸ªpreludeåº“ä¸ä¼šè¢«è‡ªåŠ¨åŠ è½½è‡³ç¨‹åºä¸­ï¼Œ
éœ€è¦ç©å®¶æ‰‹åŠ¨åŠ è½½æ‰èƒ½ä½¿ç”¨ã€‚

[prelude]: https://doc.rust-lang.org/std/prelude/index.html
[ioprelude]: https://doc.rust-lang.org/std/io/prelude/index.html

```rust
fn main() {
```

æ­£å¦‚ä¹‹å‰å·²ç»æåˆ°è¿‡çš„ï¼Œ`main()`å‡½æ•°æ˜¯æ•´ä¸ªç¨‹åºçš„å…¥å£ã€‚`fn`è¡¨ç¤ºå£°æ˜ä¸€ä¸ªå‡½æ•°ï¼Œ`()`
è¡¨ç¤ºå‡½æ•°ä¸æ¥å—ä»»ä½•å‚æ•°ï¼Œ`{`è¡¨ç¤ºç¨‹åºä½“çš„èµ·å§‹ã€‚å› ä¸ºæˆ‘ä»¬æœªæŒ‡å®šå‡½æ•°çš„è¿”å›ç±»å‹ï¼ŒRust
é»˜è®¤å‡½æ•°çš„è¿”å›ä¸º`()`ï¼Œä¸€ä¸ªç©ºçš„`å…ƒç»„`ï¼ˆ[å‚çœ‹ä¸‹ä¸€ç« ][tuples]ï¼‰ã€‚

[tuples]: åŸºæœ¬ç±»å‹.md

```rust
    println!("Guess the number!");

    println!("Please input your guess.");
```

æˆ‘ä»¬ä¹‹å‰å·²ç»å­¦ä¹ è¿‡äº†ï¼Œ`println!()`æ˜¯å¯¹[å®][macros]çš„è°ƒç”¨ï¼Œå…¶åŠŸèƒ½æ˜¯å‘ç»ˆç«¯è¾“å‡º
[å­—ç¬¦ä¸²][strings]ã€‚

[macros]: å®.md
[strings]: å­—ç¬¦ä¸².md

```rust
    let mut guess = String::new();
```

åˆ°è¿™é‡Œäº‹æƒ…å°±å˜å¾—æœ‰è¶£äº›äº†ï¼Œè¿™è¡Œä»£ç åšäº†ä¸å°‘äº‹æƒ…ã€‚é¦–å…ˆï¼Œå®ƒä½¿ç”¨äº†[letè¯­å¥][let]ï¼Œ
å…¶ç›®çš„æ˜¯åˆ›å»ºå˜é‡ç»‘å®šã€‚å˜é‡ç»‘å®šçš„åŸºæœ¬å½¢å¼å¦‚ä¸‹ï¼š

```rust
let foo = bar;
```

[let]: å˜é‡ç»‘å®š.md

è¿™æ¡ç»‘å®šè¯­å¥åˆ›å»ºäº†ä¸€ä¸ªé’ˆå¯¹å˜é‡`bar`çš„ç»‘å®šï¼Œå‘½åä¸º`foo`ã€‚åœ¨å…¶å®ƒç¼–ç¨‹è¯­è¨€ä¸­ï¼Œè¿™ä¸€èˆ¬
è¢«ç§°ä½œä¸ºä¸€ä¸ªæ–°çš„å˜é‡ï¼Œè€ŒRustä¹‹æ‰€ä»¥ç§°å…¶ä¸ºå˜é‡ç»‘å®šæ˜¯å› ä¸ºå…¶å˜é‡å¤„ç†çš„ç‰¹æ®Šæ€§ã€‚

ä¸¾ä¾‹æ¥è®²ï¼Œå˜é‡ç»‘å®šåœ¨Rustä¸­é»˜è®¤æ˜¯[ä¸å¯å˜çš„][immutable]ã€‚è¿™é‡Œæˆ‘ä»¬åœ¨å®šä¹‰å˜é‡ç»‘
å®šæ—¶ä½¿ç”¨äº†`mut`å…³é”®å­—ï¼šè¿™æ ·åˆ›å»ºçš„å˜é‡ç»‘å®šå°±æ˜¯å¯å˜çš„äº†ã€‚`let`å®é™…ä¸Šå°†ç­‰å·å·¦è¾¹çš„
éƒ¨åˆ†å½“æˆäº†[æ¨¡å¼][patterns]æ¥å¤„ç†ï¼Œè€Œä¸æ˜¯ç®€å•çš„å˜é‡åï¼Œè¿™ä¸ªæˆ‘ä»¬åé¢å†æ·±ç©¶ã€‚ç°åœ¨
æˆ‘ä»¬åªéœ€çŸ¥é“å˜é‡ç»‘å®šè¢«åˆ†ä¸ºä¸¤ç±»ï¼Œå¯å˜å’Œä¸å¯å˜ï¼š

```rust
let foo = 5; // ä¸å¯å˜
let mut bar = 5; // å¯å˜
```

[immutable]: å˜é‡å¯å˜æ€§.md
[patterns]: æ¨¡å¼.md

å’ŒC/C++ä¸€æ ·ï¼Œ`//`è¡¨ç¤º[æ³¨é‡Š][comments]çš„èµ·å§‹ï¼Œä¸€ç›´åˆ°æœ¬è¡Œæœ«å°¾ã€‚

[comments]: æ³¨é‡Š.md

ç°åœ¨æˆ‘ä»¬çŸ¥é“äº†`let mut guess`å®šä¹‰äº†ä¸€ä¸ªå‘½åä¸º`guess`çš„å¯å˜çš„å˜é‡ç»‘å®šï¼Œé‚£ä¹ˆç­‰å·å³
è¾¹çš„è¢«ç»‘å®šå¯¹è±¡`String::new()`æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ`String`æ˜¯ä¸€ä¸ªç”¨äºè¡¨ç¤ºå­—ç¬¦ä¸²çš„ç±»å‹ï¼Œæ˜¯ç”±
æ ‡å‡†åº“æä¾›çš„ã€‚ä¸€ä¸ª[`String`][string]è¡¨ç¤ºäº†ä¸€ä¸²å¯åŠ¨æ€å¢é•¿çš„ã€UTF-8ç¼–ç çš„æ–‡æœ¬ä¿¡æ¯ã€‚

[string]: https://doc.rust-lang.org/std/string/struct.String.html

`::new()`è¯­å¥ä½¿ç”¨äº†`::`ç¬¦å·ï¼Œè¿™æ˜¯å› ä¸º`new()`æ˜¯ä¸ç‰¹å®šç±»å‹å…³è”çš„å‡½æ•°ï¼Œåœ¨æœ¬ä¾‹å³ç‰¹æŒ‡
`String`ç±»å‹ã€‚æ³¨æ„æ˜¯ä¸ç±»å‹è€Œä¸æ˜¯ä¸ç±»å‹å®ä¾‹ç›¸å…³è”ï¼Œåœ¨å…¶å®ƒç¼–ç¨‹è¯­è¨€ä¸­è¿™ç§å‡½æ•°ä¸€èˆ¬è¢«
ç§°ä¸ºé™æ€æ–¹æ³•ã€‚

è¿™ä¸ªå‡½æ•°çš„åç§°ä¸º`new()`ï¼Œé¡¾åæ€ä¹‰ï¼Œå®ƒåˆ›å»ºäº†ä¸€ä¸ªæ–°çš„`String`å®ä¾‹ã€‚è®¸å¤šç±»å‹éƒ½ä»¥
`new()`ä½œä¸ºåˆ›å»ºå®ä¾‹çš„å‡½æ•°ã€‚

æˆ‘ä»¬ç»§ç»­åˆ†æä¸‹é¢çš„ä»£ç ï¼š

```rust
    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");
```

è¿™è¡Œä»£ç å°±æ›´å¤æ‚äº†ï¼Œæˆ‘ä»¬ä¸€ç‚¹ä¸€ç‚¹æ¥ï¼š

```rust
io::stdin()
```

è¿™é‡Œæˆ‘ä»¬è°ƒç”¨äº†`io`åº“çš„`stdin()`å‡½æ•°ï¼Œè¿˜è®°å¾—æˆ‘ä»¬åœ¨ç¨‹åºçš„å¼€å§‹åŠ è½½äº†`std::io`åº“å—ï¼Œ
å¦‚æœæ²¡æœ‰é‚£ä¹ˆåšï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œå°±è¦å†™æˆ`std::io::stdin()`ã€‚

è¿™ä¸ªå‡½æ•°å‘æˆ‘ä»¬è¿”å›äº†å½“å‰ç»ˆç«¯çš„æ ‡å‡†è¾“å…¥çš„å¥æŸ„ï¼Œ
å…·ä½“è¯·å‚é˜…[std::io::Stdin][iostdin]ã€‚

[iostdin]: https://doc.rust-lang.org/std/io/struct.Stdin.html

ä¸‹é¢çš„ä»£ç é€šè¿‡è¿™ä¸ªå¥æŸ„ä»ç”¨æˆ·è·å–è¾“å…¥ä¿¡æ¯ï¼š

```rust
.read_line(&mut guess)
```

è¿™é‡Œæˆ‘ä»¬è°ƒç”¨äº†å¥æŸ„çš„[`read_line()`][read_line]æ–¹æ³•ã€‚[æ–¹æ³•][method]ä¸ä¸Šé¢çš„å…³è”
å‡½æ•°ç±»ä¼¼ï¼Œåªä¸è¿‡å®ƒæ˜¯è¢«å…³è”åˆ°ç‰¹å®šç±»å‹çš„å®ä¾‹ä¸Šçš„å‡½æ•°ã€‚

[read_line]: https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line
[method]: æ–¹æ³•.md

è¿˜è®°å¾—æˆ‘ä»¬ä¹‹å‰åˆ›å»ºçš„guessç»‘å®šå—ï¼Ÿæˆ‘ä»¬å·²ç»æè¿‡äº†guessæ˜¯ä¸ªå¯å˜çš„å˜é‡ç»‘å®šã€‚è¿™é‡Œéœ€è¦
è§£é‡Šä¸€ä¸‹ï¼Œä¸ºä»€ä¹ˆä¸èƒ½ç›´æ¥æŠŠguessä¼ é€’ç»™read_lineå‡½æ•°ã€‚é¦–å…ˆï¼Œ`read_line`æ¥å—çš„å‚æ•°
ç±»å‹æ˜¯`&mut String`ï¼Œè€Œä¸æ˜¯`String`ï¼›Rustè¯­è¨€æœ‰ä¸ªç‰¹æ€§ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º
[å¼•ç”¨][references]ï¼Œè¿™ä¸ªç‰¹æ€§å…è®¸ä½ é€šè¿‡å¤šä¸ªå¼•ç”¨è®¿é—®åŒä¸€å—æ•°æ®ï¼Œä»è€Œé™ä½äº†æ‹·è´æ•°æ®
çš„å¿…è¦æ€§ã€‚å¼•ç”¨æ˜¯ä¸ªæ¯”è¾ƒå¤æ‚çš„ç‰¹æ€§ï¼ŒRustæœ€å¤§çš„å–ç‚¹ä¹‹ä¸€å°±æ˜¯èƒ½å¤Ÿå®‰å…¨ä¸”è¾ƒä¸ºç®€æ˜“çš„ä½¿ç”¨
å¼•ç”¨ã€‚æˆ‘ä»¬æš‚æ—¶ä¸ç”¨æ·±ç©¶å…¶ç»†èŠ‚ï¼Œè¿™é‡Œæˆ‘ä»¬åªéœ€çŸ¥é“å’Œ`let`ç»‘å®šæ–¹å¼ä¸€æ ·ï¼Œå¼•ç”¨ä¹Ÿé»˜è®¤æ˜¯
ä¸å¯å˜çš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦å†™æˆ`&mut guess`ï¼Œè€Œä¸æ˜¯`&guess`ã€‚

ä¸ºä»€ä¹ˆ`read_line()`éœ€è¦ä¸€ä¸ªå¯å˜çš„å¼•ç”¨ä½œä¸ºå‚æ•°å‘¢ï¼Ÿå¾ˆæ˜¾ç„¶ï¼Œè¿™ä¸ªå‡½æ•°çš„å·¥ä½œå°±æ˜¯è¯»å–
ç”¨æˆ·çš„è¾“å…¥å¹¶å°†å…¶æ”¾ç½®åˆ°ä¼ å…¥å‚æ•°ä¸­ï¼Œå› æ­¤å‚æ•°çš„ç±»å‹å¿…é¡»ä¸ºå¯å˜çš„ã€‚

[references]: å¼•ç”¨å’Œå€Ÿç”¨.md

æ¥ä¸‹æ¥çš„ä»£ç æ˜¯ï¼š

```rust
        .expect("Failed to read line");
```

å½“ä½ è°ƒç”¨ä¸€ä¸ªæ–¹æ³•æ—¶ï¼Œä½ å¯ä»¥æ·»åŠ æ¢è¡Œç¬¦å’Œç©ºç™½ç¬¦ï¼Œè¿™å¯ä»¥å¸®åŠ©ä½ ç¾åŒ–ä»£ç ã€‚è™½ç„¶æˆ‘ä»¬ä¹Ÿ
å¯ä»¥å°†ä»£ç å†™æˆï¼š

```rust
    io::stdin().read_line(&mut guess).expect("failed to read line");
```

ä½†æ˜¯å¾ˆæ˜¾ç„¶è¿™æ ·çš„ä»£ç çš„å¯è¯»æ€§å¤§å¤§é™ä½äº†ã€‚å› æ­¤æˆ‘ä»¬é€šå¸¸ä¼šå°†è¿ç»­çš„æ–¹æ³•è°ƒç”¨åˆ†åˆ«å†™æˆ
å•ç‹¬çš„è¡Œã€‚é‚£ä¹ˆè¿™é‡Œçš„`expect()`æ–¹æ³•æ˜¯åšä»€ä¹ˆç”¨çš„å‘¢ï¼Ÿäº‹å®ä¸Šï¼Œ`read_line()`æ–¹æ³•ä¼š
è¿”å›ä¸€ä¸ª[`io::Result`][ioresult]ç±»å‹çš„å˜é‡ã€‚Rustçš„æ ‡å‡†åº“ä¸­æœ‰è®¸å¤šè¢«å‘½åä¸º`Result`
çš„ç±»å‹â€”â€”å®ƒä»¬å…¶å®éƒ½æ˜¯åŸºäºåŒä¸€ä¸ª[`æ³›å‹Result`][result]ï¼Œ`io::Result`æ­£æ˜¯å…¶ä¸­ä¹‹ä¸€ã€‚

[ioresult]: https://doc.rust-lang.org/std/io/type.Result.html
[result]: https://doc.rust-lang.org/std/result/enum.Result.html

`Result`ç±»å‹çš„ç›®çš„æ˜¯å°†é”™è¯¯ä¿¡æ¯å°è£…èµ·æ¥ï¼Œ`Result`çš„å®ä¾‹åŒæ ·ä¹Ÿæœ‰å…³è”çš„æ–¹æ³•ï¼Œè¿™é‡Œ
è°ƒç”¨çš„[`expect()`æ–¹æ³•][expect]æ­£æ˜¯å…¶ä¸­ä¹‹ä¸€ã€‚å¦‚æœè¿™é‡Œçš„`Result`å®ä¾‹ä»£è¡¨äº†å¤±è´¥ï¼Œ
åˆ™[`panic!`][panic]ä¼šè¢«è°ƒç”¨ï¼Œå…¶å…¥å‚æ­£æ˜¯ä½ ä¼ ç»™`expect`çš„å‚æ•°ã€‚`panic!`çš„æ‰§è¡Œæ•ˆæœ
æ˜¯ä½¿ç¨‹åºå´©æºƒï¼ŒåŒæ—¶ç»™å‡ºé”™è¯¯ä¿¡æ¯ã€‚

[expect]: https://doc.rust-lang.org/std/result/enum.Result.html#method.expect
[panic]: é”™è¯¯å¤„ç†.md

å¦‚æœæˆ‘ä»¬ä¸è°ƒç”¨`expect()`æ–¹æ³•ï¼Œç¨‹åºåœ¨ç¼–è¯‘æ—¶ä¼šç»™å‡ºå¦‚ä¸‹å‘Šè­¦ä¿¡æ¯ï¼š

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:10:5: 10:39 warning: unused result which must be used,
#[warn(unused_must_use)] on by default
src/main.rs:10     io::stdin().read_line(&mut guess);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

å¯ä»¥çœ‹åˆ°ï¼ŒRustç¼–è¯‘å™¨æé†’äº†æˆ‘ä»¬`Result`å˜é‡æ²¡æœ‰è¢«ä½¿ç”¨ï¼Œé€šè¿‡è¿™ç§æ–¹å¼Rustå‘Šè¯‰æˆ‘ä»¬
ç¨‹åºä¸­æœ‰é”™è¯¯å¯èƒ½æœªè¢«å¤„ç†ã€‚æ­£ç¡®çš„æ–¹å¼æ˜¯å¯¹å‡½æ•°è¿”å›åŠ ä»¥å¤„ç†ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬å¸Œæœ›ç¨‹åº
åœ¨é‡åˆ°é—®é¢˜æ—¶å¥”æºƒå³å¯ï¼Œå› æ­¤å¯ä»¥ç›´æ¥è°ƒç”¨`expect()`æ–¹æ³•ã€‚å¦‚æœé”™è¯¯æ˜¯èƒ½å¤Ÿé€šè¿‡æŸç§æ–¹å¼
æ¢å¤çš„ï¼Œæˆ‘ä»¬å°±è¦é‡‡å–å…¶å®ƒçš„åŠæ³•ï¼Œè¿™ä¸ªæˆ‘ä»¬ç•™å¾…åè¿°ã€‚

ç°åœ¨å°±å‰©ä¸‹æœ€åä¸€ç‚¹ä»£ç äº†ï¼š

```rust
    println!("You guessed: {}", guess);
}
```

è¿™é‡Œè¾“å‡ºäº†æˆ‘ä»¬ä¿å­˜çš„ç©å®¶è¾“å…¥çš„ä¿¡æ¯ã€‚`{}`æ˜¯ä¸€ä¸ªå ä½ç¬¦ï¼Œå®ƒä¼šè¢«æˆ‘ä»¬å®é™…ä¼ ç»™
`println!`çš„guesså‚æ•°æ‰€æ›¿ä»£ã€‚å¦‚æœæˆ‘ä»¬æœ‰å¤šä¸ª`{}`ï¼Œæˆ‘ä»¬å°±éœ€è¦ä¼ å…¥ç›¸åº”æ•°é‡çš„å‚æ•°ï¼š

```rust
let x = 5;
let y = 10;

println!("x and y: {} and {}", x, y);
```

å¾ˆç®€å•å§ï¼Ÿ

ä»£ç å·²ç»è®²å®Œäº†ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥è¿è¡Œç¨‹åºäº†ï¼š

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```

å¥½äº†ï¼ç¨‹åºçš„ç¬¬ä¸€é˜¶æ®µå·²ç»å®Œæˆäº†ï¼Œæˆ‘ä»¬å·²ç»èƒ½å¤Ÿä»é”®ç›˜è·å–è¾“å…¥ï¼Œå¹¶ä¸”å°†è¾“å…¥å†è¾“å‡ºåˆ°
å±å¹•ä¸Šã€‚

# ç”Ÿæˆä¸€ä¸ªç§˜å¯†æ•°å­—

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªéšæœºæ•°ç”Ÿæˆå™¨ã€‚Rustç›®å‰æ²¡æœ‰åœ¨æ ‡å‡†åº“ä¸­æä¾›éšæœºæ•°ç”Ÿæˆå™¨ï¼Œæˆ‘ä»¬
éœ€è¦ä½¿ç”¨ä¸€ä¸ª[`rand` crate][randcrate]ã€‚'crate'è¡¨ç¤ºä¸€å †Rustç¼–å†™çš„ä»£ç ï¼Œå¯èƒ½æ˜¯ä¸ª
å¯è¿è¡Œçš„äºŒè¿›åˆ¶ç¨‹åºï¼Œä¹Ÿå¯èƒ½æ˜¯ä¸ªå…±äº«åº“ã€‚è¿™é‡Œæ‰€è¯´çš„`rand`å°±æ˜¯ä¸ªå…±äº«åº“crateã€‚

[randcrate]: https://crates.io/crates/rand

Cargoçš„ä¼˜åŠ¿åœ¨è¿™ä¸ªæ—¶å€™å°±ä½“ç°å‡ºæ¥äº†ï¼Œæˆ‘ä»¬åœ¨`Cargo.toml`é…ç½®ä¸­æ·»åŠ ä»¥ä¸‹é…ç½®å³å¯å°†ä¾
èµ–çš„randåº“åŠ å…¥å·¥ç¨‹ï¼š

```toml
[dependencies]

rand="0.3.0"
```

`[dependencies]`é…ç½®æ®µå’Œ`[package]`ä¸€æ ·ï¼Œè·Ÿéšåœ¨å…¶åçš„æ‰€æœ‰é…ç½®éƒ½å±äºå®ƒï¼Œç›´åˆ°æ–‡ä»¶
ç»“æŸæˆ–è€…å¦ä¸€ä¸ªé…ç½®æ®µå¼€å§‹ã€‚Cargoé€šè¿‡dependenciesé…ç½®æ®µè·å–é¡¹ç›®æ‰€ä¾èµ–çš„ç¬¬ä¸‰æ–¹åº“çš„
ä¿¡æ¯â€”â€”åç§°ã€ç‰ˆæœ¬ç­‰ã€‚åœ¨æœ¬ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬æŒ‡å®šçš„ç‰ˆæœ¬å·`0.3.0`æ˜¯`^0.3.0`çš„ç®€å†™æ–¹å¼ï¼Œè¡¨
ç¤ºæ‰€æœ‰ä¸`0.3.0`ç›¸å…¼å®¹çš„ç‰ˆæœ¬ï¼Œå…·ä½“å‚è€ƒ[Semantic Versioning][semver]ã€‚
å¦‚æœæˆ‘ä»¬éœ€è¦æ˜ç¡®çš„æŒ‡å®šä½¿ç”¨`0.3.0`ç‰ˆæœ¬ï¼Œé…ç½®åº”è¯¥å†™ä¸º`rand = "=0.3.0"`ã€‚
å¦‚æœæˆ‘ä»¬å¸Œæœ›ä½¿ç”¨æœ€æ–°çš„ç‰ˆæœ¬ï¼Œåˆ™é…ç½®åº”è¯¥å†™ä¸º`rand = "*"`ã€‚
[Cargoæ–‡æ¡£][cargodoc]ä¸­æœ‰æ›´å¤šçš„ç»†èŠ‚å¯å‚è€ƒã€‚

[semver]: http://semver.org
[cargodoc]: http://doc.crates.io/specifying-dependencies.html

ç°åœ¨è®©æˆ‘ä»¬å†å°è¯•ç¼–è¯‘ä»£ç ï¼š

```bash
$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.8
 Downloading libc v0.1.6
   Compiling libc v0.1.6
   Compiling rand v0.3.8
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
```

è§‚å¯Ÿç¼–è¯‘è¾“å‡ºå³å¯å‘ç°Cargoè‡ªåŠ¨ä¸‹è½½äº†ä¾èµ–åº“çš„æ–°ç‰ˆæœ¬ï¼Œè¿™æ˜¯ä»[Crates.io][cratesio]
ä¸‹è½½çš„ã€‚Crates.ioæ˜¯å®˜æ–¹çš„Rustä»£ç å…±äº«å’Œå‘å¸ƒä¸­å¿ƒã€‚

[cratesio]: https://crates.io

åœ¨ä¸Šé¢çš„è¾“å‡ºä¸­æˆ‘ä»¬çœ‹Cargoè¿˜ä¸‹è½½äº†libcåº“ï¼Œè¿™æ˜¯å› ä¸ºrandåº“å¯¹libcåº“æœ‰ä¾èµ–ã€‚

åœ¨ä¸Šé¢æˆ‘ä»¬æåˆ°äº†ï¼Œæˆ‘ä»¬æ‰€ä¾èµ–çš„`rand`åº“çš„ç‰ˆæœ¬å®é™…ä¸Šæ˜¯`0.3.x`ã€‚ç°åœ¨æˆ‘ä»¬å·²ç»ä¸‹è½½äº†
`0.3.8`ç‰ˆæœ¬ï¼Œå‡å¦‚è¿‡ä¸€å‘¨åæ–°çš„ç‰ˆæœ¬`0.3.9`å‘å¸ƒäº†æ€ä¹ˆåŠï¼Ÿ`cargo build`å‘½ä»¤æ˜¯å¦ä¼šè‡ª
åŠ¨æ›´æ–°ç‰ˆæœ¬å‘¢ï¼Ÿç­”æ¡ˆæ˜¯å¦å®šçš„ã€‚è¿™æ˜¯å› ä¸ºæ–°çš„ç‰ˆæœ¬åœ¨ä¿®å¤ä»¥å‰çš„bugçš„åŒæ—¶ä¹Ÿå¯èƒ½ä¼šå¼•å…¥æ–°
çš„bugï¼Œç”šè‡³æ¥å£çš„å˜åŒ–ã€‚`Cargo`çš„ç­–ç•¥æ˜¯è®°å½•ä¸Šä¸€æ¬¡æ„å»ºæ‰€ç”¨çš„ç‰ˆæœ¬ï¼Œåç»­çš„æ„å»ºä¼šç»§ç»­
ä½¿ç”¨ä¸Šæ¬¡æ„å»ºæ‰€ç”¨çš„ç‰ˆæœ¬ï¼Œé™¤éå¼€å‘è€…ä¸»åŠ¨è¦æ±‚æ›´æ–°ç‰ˆæœ¬ã€‚é‚£ä¹ˆ`Cargo`æ˜¯å¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹
çš„å‘¢ï¼Ÿç­”æ¡ˆæ˜¯é€šè¿‡`Cargo.lock`æ–‡ä»¶ï¼Œ`Cargo`åœ¨è¿™ä¸ªæ–‡ä»¶ä¸­è®°å½•ä¸Šæ¬¡æ„å»ºä¸­ä½¿ç”¨çš„ç‰ˆæœ¬ï¼Œ
ä¹‹å`Cargo`æ¯æ¬¡è¿è¡Œæ—¶åªè¦å‘ç°æœ‰`Cargo.lock`æ–‡ä»¶å­˜åœ¨åˆ™ç›´æ¥ä½¿ç”¨è¯¥æ–‡ä»¶ä¸­è®°å½•çš„ç‰ˆæœ¬
ä¿¡æ¯ã€‚

é‚£ä¹ˆå¦‚ä½•å‘Šè¯‰`Cargo`å»æ›´æ–°ç‰ˆæœ¬å‘¢ï¼ŸCargoæœ‰ä¸ªå­å‘½ä»¤ä¸“ç”¨äºæ­¤ï¼š`update`ã€‚è¿™ä¸ªå‘½ä»¤å¯ä»¥
ä½¿`Cargo`å¿½ç•¥å½“å‰çš„`Cargo.lock`æ–‡ä»¶ï¼Œå¹¶é‡æ–°å°è¯•å»ç¡®å®šä¾èµ–é¡¹çš„ç‰ˆæœ¬å·ï¼Œç¡®å®šå®Œæˆå
å†å°†æ–°çš„ç‰ˆæœ¬å·å†™å…¥`Cargo.lock`æ–‡ä»¶ã€‚ä¹‹åå½“æˆ‘ä»¬å†æ¬¡è¿è¡Œ`cargo build`æ—¶ï¼ŒCargoä¼š
è‡ªåŠ¨æ›´æ–°ä¾èµ–åº“è‡³æ–°ç‰ˆæœ¬ã€‚

å…³äº`Cargo`è¿˜æœ‰å¾ˆå¤šè¯é¢˜ï¼Œæ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥å»æ·±å…¥é˜…è¯»[Cargoå®˜æ–¹æ–‡æ¡£]ã€doccargo]ï¼Œ
å¹¶äº†è§£å…¶[ç”Ÿæ€ç³»ç»Ÿ][doccratesio]ã€‚

[doccargo]: http://doc.crates.io
[doccratesio]: http://doc.crates.io/crates-io.html

ä¸‹é¢è®©æˆ‘ä»¬ä½¿ç”¨`rand`åº“æ¥å®Œå–„æˆ‘ä»¬çš„ç¨‹åºï¼š

```rust
extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("failed to read line");

    println!("You guessed: {}", guess);
}
```

æˆ‘ä»¬åœ¨ä»£ç çš„ç¬¬ä¸€è¡Œé¦–å…ˆå¯¹å¼•ç”¨çš„ç¬¬ä¸‰æ–¹åº“è¿›è¡Œäº†å£°æ˜ï¼š`extern crate rand;`ã€‚è¿™è¡Œä»£ç 
çš„ç›®çš„æ˜¯å‘Šè¯‰rustæˆ‘ä»¬ä¼šåœ¨åé¢çš„ä»£ç ä¸­ä½¿ç”¨randåº“ï¼Œå…¶ä½œç”¨å’Œ`use rand;`æœ‰äº›ç±»ä¼¼ï¼Œå
ç»­æˆ‘ä»¬å¯ä»¥é€šè¿‡æ·»åŠ å‰ç¼€`rand::`çš„æ–¹å¼æ¥è°ƒç”¨`rand`åº“ä¸­çš„æ¥å£ã€‚

æ¥ä¸‹æ¥æˆ‘ä»¬è¿˜æ·»åŠ äº†ä¸€è¡Œ`use rand::Rng`ï¼Œè¿™è¡Œä»£ç çš„ç›®çš„æ˜¯ä¸ºäº†å°†`Rng`çš„å®šä¹‰å‘Šè¯‰
rustã€‚äº‹å®ä¸Šï¼Œæˆ‘ä»¬å³å°†è°ƒç”¨çš„`rand`æ¨¡å—çš„æ–¹æ³•æ˜¯è¢«å®šä¹‰åœ¨traitsä¸­çš„ï¼Œä¸ºäº†èƒ½å¤Ÿä½¿ç”¨
è¯¥æ–¹æ³•ï¼Œtraitsçš„å®šä¹‰å¿…é¡»è¢«å¯¼å…¥åˆ°å½“å‰ç¼–è¯‘å•å…ƒä¸­ã€‚å…·ä½“å‚è§åç»­çš„[traits][traits]ã€‚

[traits]: traits.md

æ¥ä¸‹æ¥æ˜¯ç”Ÿæˆå¹¶æ‰“å°éšæœºæ•°çš„ä»£ç ï¼š

```rust
    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);
```

æˆ‘ä»¬ä½¿ç”¨`rand::thread_rng()`å‡½æ•°è·å–äº†ä¸€ä»½éšæœºæ•°ç”Ÿæˆå™¨çš„æ‹·è´ï¼Œè¯¥ç”Ÿæˆå™¨å±äºå½“å‰
çš„æ‰§è¡Œä¸Šä¸‹æ–‡ï¼ˆ[thread][concurrency])ã€‚ç”±äºæˆ‘ä»¬åœ¨ä¸Šé¢å·²ç»é€šè¿‡`use rand::Rng`å¯¼å…¥
äº†ç›¸å…³traitsçš„å®šä¹‰ï¼Œè¿™é‡Œæˆ‘ä»¬å¯ä»¥è°ƒç”¨`gen_range()`æ–¹æ³•æ¥è·å–éšæœºæ•°ã€‚è¿™ä¸ªæ–¹æ³•æ¥å—
ä¸¤ä¸ªæ•°å€¼ï¼Œè¿”å›ç»“æœæ˜¯ä½äºä¸¤ä¸ªæ•°ä¹‹é—´çš„æŸä¸ªéšæœºæ•°ï¼ˆåŒ…å«ä¸‹é™ï¼Œä¸åŒ…å«ä¸Šé™ï¼‰ã€‚

[concurrency]: å¹¶å‘.md

ä¸‹é¢æˆ‘ä»¬è¯•ç€è¿è¡Œç¨‹åºï¼š

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
```

çœ‹èµ·æ¥ä¸€åˆ‡é¡ºåˆ©ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬éœ€è¦æ¯”è¾ƒéšæœºæ•°å’Œç©å®¶çŒœæµ‹çš„æ•°å­—ã€‚

# Comparing guesses

Now that weâ€™ve got user input, letâ€™s compare our guess to the secret number.
Hereâ€™s our next step, though it doesnâ€™t quite compile yet:

```rust
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("failed to read line");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less    => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal   => println!("You win!"),
    }
}
```

A few new bits here. The first is another `use`. We bring a type called
`std::cmp::Ordering` into scope. Then, five new lines at the bottom that use
it:

```rust
match guess.cmp(&secret_number) {
    Ordering::Less    => println!("Too small!"),
    Ordering::Greater => println!("Too big!"),
    Ordering::Equal   => println!("You win!"),
}
```

The `cmp()` method can be called on anything that can be compared, and it
takes a reference to the thing you want to compare it to. It returns the
`Ordering` type we `use`d earlier. We use a [`match`][match] statement to
determine exactly what kind of `Ordering` it is. `Ordering` is an
[`enum`][enum], short for â€˜enumerationâ€™, which looks like this:

```rust
enum Foo {
    Bar,
    Baz,
}
```

[match]: æ¨¡å¼åŒ¹é….md
[enum]: æšä¸¾.md

With this definition, anything of type `Foo` can be either a
`Foo::Bar` or a `Foo::Baz`. We use the `::` to indicate the
namespace for a particular `enum` variant.

The [`Ordering`][ordering] `enum` has three possible variants: `Less`, `Equal`,
and `Greater`. The `match` statement takes a value of a type, and lets you
create an â€˜armâ€™ for each possible value. Since we have three types of
`Ordering`, we have three arms:

```rust
match guess.cmp(&secret_number) {
    Ordering::Less    => println!("Too small!"),
    Ordering::Greater => println!("Too big!"),
    Ordering::Equal   => println!("You win!"),
}
```

[ordering]: https://doc.rust-lang.org/std/cmp/enum.Ordering.html

If itâ€™s `Less`, we print `Too small!`, if itâ€™s `Greater`, `Too big!`, and if
`Equal`, `You win!`. `match` is really useful, and is used often in Rust.

I did mention that this wonâ€™t quite compile yet, though. Letâ€™s try it:

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:28:21: 28:35 error: mismatched types:
 expected `&collections::string::String`,
    found `&_`
(expected struct `collections::string::String`,
    found integral variable) [E0308]
src/main.rs:28     match guess.cmp(&secret_number) {
                                   ^~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `guessing_game`.
```

Whew! This is a big error. The core of it is that we have â€˜mismatched typesâ€™.
Rust has a strong, static type system. However, it also has type inference.
When we wrote `let guess = String::new()`, Rust was able to infer that `guess`
should be a `String`, and so it doesnâ€™t make us write out the type. And with
our `secret_number`, there are a number of types which can have a value
between one and a hundred: `i32`, a thirty-two-bit number, or `u32`, an
unsigned thirty-two-bit number, or `i64`, a sixty-four-bit number or others.
So far, that hasnâ€™t mattered, and so Rust defaults to an `i32`. However, here,
Rust doesnâ€™t know how to compare the `guess` and the `secret_number`. They
need to be the same type. Ultimately, we want to convert the `String` we
read as input into a real number type, for comparison. We can do that
with two more lines. Hereâ€™s our new program:

```rust
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("failed to read line");

    let guess: u32 = guess.trim().parse()
        .expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less    => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal   => println!("You win!"),
    }
}
```

The new two lines:

```rust
    let guess: u32 = guess.trim().parse()
        .expect("Please type a number!");
```

Wait a minute, I thought we already had a `guess`? We do, but Rust allows us
to â€˜shadowâ€™ the previous `guess` with a new one. This is often used in this
exact situation, where `guess` starts as a `String`, but we want to convert it
to an `u32`. Shadowing lets us re-use the `guess` name, rather than forcing us
to come up with two unique names like `guess_str` and `guess`, or something
else.

We bind `guess` to an expression that looks like something we wrote earlier:

```rust
guess.trim().parse()
```

Here, `guess` refers to the old `guess`, the one that was a `String` with our
input in it. The `trim()` method on `String`s will eliminate any white space at
the beginning and end of our string. This is important, as we had to press the
â€˜returnâ€™ key to satisfy `read_line()`. This means that if we type `5` and hit
return, `guess` looks like this: `5\n`. The `\n` represents â€˜newlineâ€™, the
enter key. `trim()` gets rid of this, leaving our string with only the `5`. The
[`parse()` method on strings][parse] parses a string into some kind of number.
Since it can parse a variety of numbers, we need to give Rust a hint as to the
exact type of number we want. Hence, `let guess: u32`. The colon (`:`) after
`guess` tells Rust weâ€™re going to annotate its type. `u32` is an unsigned,
thirty-two bit integer. Rust has [a number of built-in number types][number],
but weâ€™ve chosen `u32`. Itâ€™s a good default choice for a small positive number.

[parse]: https://doc.rust-lang.org/std/primitive.str.html#method.parse
[number]: åŸºæœ¬ç±»å‹.md

Just like `read_line()`, our call to `parse()` could cause an error. What if
our string contained `AğŸ‘%`? Thereâ€™d be no way to convert that to a number. As
such, weâ€™ll do the same thing we did with `read_line()`: use the `expect()`
method to crash if thereâ€™s an error.

Letâ€™s try our program out!

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```

Nice! You can see I even added spaces before my guess, and it still figured
out that I guessed 76. Run the program a few times, and verify that guessing
the number works, as well as guessing a number too small.

Now weâ€™ve got most of the game working, but we can only make one guess. Letâ€™s
change that by adding loops!

# Looping

The `loop` keyword gives us an infinite loop. Letâ€™s add that in:

```rust
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("failed to read line");

        let guess: u32 = guess.trim().parse()
            .expect("Please type a number!");

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal   => println!("You win!"),
        }
    }
}
```

And try it out. But wait, didnâ€™t we just add an infinite loop? Yup. Remember
our discussion about `parse()`? If we give a non-number answer, weâ€™ll `panic!`
and quit. Observe:

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!'
```

Ha! `quit` actually quits. As does any other non-number input. Well, this is
suboptimal to say the least. First, letâ€™s actually quit when you win the game:

```rust
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("failed to read line");

        let guess: u32 = guess.trim().parse()
            .expect("Please type a number!");

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal   => {
                println!("You win!");
                break;
            }
        }
    }
}
```

By adding the `break` line after the `You win!`, weâ€™ll exit the loop when we
win. Exiting the loop also means exiting the program, since itâ€™s the last
thing in `main()`. We have only one more tweak to make: when someone inputs a
non-number, we donâ€™t want to quit, we want to ignore it. We can do that
like this:

```rust
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal   => {
                println!("You win!");
                break;
            }
        }
    }
}
```

These are the lines that changed:

```rust
let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};
```
This is how you generally move from â€˜crash on errorâ€™ to â€˜actually handle the
errorâ€™, by switching from `expect()` to a `match` statement. A `Result` is
returned by `parse()`, this is an `enum`  like `Ordering`, but in this case,
each variant has some data associated with it: `Ok` is a success, and `Err` is a
failure. Each contains more information: the successfully parsed integer, or an
error type. In this case, we `match` on `Ok(num)`, which sets the name `num` to
the unwrapped `Ok` value (the integer), and then we  return it on the
right-hand side. In the `Err` case, we donâ€™t care what kind of error it is, so
we just use the catch all `_` instead of a name. This catches everything that
isn't `Ok`, and `continue` lets us move to the next iteration of the loop; in
effect, this enables us to ignore all errors and continue with our program.

Now we should be good! Letâ€™s try:

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
```

Awesome! With one tiny last tweak, we have finished the guessing game. Can you
think of what it is? Thatâ€™s right, we donâ€™t want to print out the secret
number. It was good for testing, but it kind of ruins the game. Hereâ€™s our
final source:

```rust
extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal   => {
                println!("You win!");
                break;
            }
        }
    }
}
```

# Complete!

This project showed you a lot: `let`, `match`, methods, associated
functions, using external crates, and more.

At this point, you have successfully built the Guessing Game! Congratulations!
