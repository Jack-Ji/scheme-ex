% æ¨¡å¼

æ¨¡å¼åœ¨Rustä¸­ç»å¸¸è¢«ç”¨åˆ°ï¼Œæˆ‘ä»¬ä¸€èˆ¬åœ¨[å˜é‡ç»‘å®š][bindings]å’Œ[match][match]ä¸­ä½¿ç”¨å®ƒã€‚

[bindings]: å˜é‡ç»‘å®š.md
[match]: match.md

å…³äºæ¨¡å¼ï¼Œä½ é¦–å…ˆéœ€è¦çŸ¥é“çš„æ˜¯å¯ä»¥å¯¹ä»»ä½•å­—é¢é‡ç›´æ¥è¿›è¡ŒåŒ¹é…ï¼Œå¹¶ä¸”`_`è¡¨ç¤ºä»»æ„åŒ¹é…ã€‚

```rust
let x = 1;

match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

ä»¥ä¸Šä»£ç è¾“å‡º`one`ã€‚

æ¨¡å¼åŒ¹é…ä¼šå¼•å…¥æ–°çš„å˜é‡ç»‘å®šï¼Œå®ƒä¼šä½¿å…¶å®ƒåŒåçš„å˜é‡ç»‘å®šæš‚æ—¶ä¸å¯ç”¨ï¼Œä¾‹å¦‚ï¼š

```rust
let x = 1;
let c = 'c';

match c {
    x => println!("x: {} c: {}", x, c),
}

println!("x: {}", x)
```

ä¸Šé¢çš„ä»£ç è¾“å‡ºå¦‚ä¸‹ï¼š

```text
x: c c: c
x: 1
```

ä¸Šé¢çš„ä»£ç ä¸­ï¼Œåˆ†æ”¯`x =>`åˆ›å»ºäº†æ–°çš„å˜é‡ç»‘å®š`x`ï¼Œè¯¥å˜é‡ç»‘å®šåœ¨åˆ†æ”¯çš„è¡¨è¾¾å¼å†…æœ‰æ•ˆã€‚

# å¤šæ¨¡å¼åŒ¹é…

å¯ä½¿ç”¨`|`å¯¹å¤šä¸ªæ¨¡å¼åŒæ—¶è¿›è¡ŒåŒ¹é…ï¼š

```rust
let x = 1;

match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

ä»¥ä¸Šä»£ç è¾“å‡º`one or two`ã€‚

# æ‹†åˆ†

å¯¹äº[`struct`][struct]è¿™æ ·çš„å¤åˆç±»å‹ï¼Œä½ å¯ä»¥é€šè¿‡æ¨¡å¼å¯¹å…¶è¿›è¡Œæ‹†åˆ†ï¼š

```rust
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x, y } => println!("({},{})", x, y),
}
```

[struct]: ç»“æ„ä½“.md

å¯ä½¿ç”¨`:`ä¸ºå†…éƒ¨æˆå‘˜è‡ªå®šä¹‰å˜é‡ç»‘å®šåç§°ï¼š

```rust
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x: x1, y: y1 } => println!("({},{})", x1, y1),
}
```

å¦‚æœæˆ‘ä»¬åªå…³å¿ƒä¸€éƒ¨åˆ†æ•°æ®ï¼Œå¯ä»¥çœç•¥æ‰å…¶å®ƒæ•°æ®çš„åŒ¹é…ï¼š

```rust
struct Point {
    x: i32,
    y: i32,
}

let point = Point { x: 2, y: 3 };

match point {
    Point { x, .. } => println!("x is {}", x),
}

```

ä»¥ä¸Šä»£ç çš„è¾“å‡ºä¸º`x is 2`ã€‚

ä½ å¯ä»¥æŒ‡å®šç»“æ„ä½“çš„ä»»æ„æˆå‘˜ï¼š

```rust
struct Point {
    x: i32,
    y: i32,
}

let point = Point { x: 2, y: 3 };

match point {
    Point { y, .. } => println!("y is {}", y),
}
```

ä»¥ä¸Šä»£ç è¾“å‡º`y is 3`ã€‚

æ¨¡å¼ä¸æ­¢å¯ä»¥æ‹†åˆ†ç»“æ„ä½“ï¼Œå…¶å®ƒçš„å¤åˆç±»å‹ä¹ŸåŒæ ·é€‚ç”¨ï¼Œå¦‚[å…ƒç»„][tuples]å’Œ[æšä¸¾][enums]ã€‚

[tuples]: åŸºæœ¬ç±»å‹.md
[enums]: æšä¸¾.md

# `_`æ¨¡å¼

ä½ å¯ä»¥åœ¨æ¨¡å¼ä¸­ä½¿ç”¨`_`ä»¥è¡¨ç¤ºå¿½ç•¥æ‰æŸéƒ¨åˆ†ç±»å‹å’Œå€¼ï¼Œä¾‹å¦‚ï¼š

```rust
# let some_value: Result<i32, &'static str> = Err("There was an error");
match some_value {
    Ok(value) => println!("got a value: {}", value),
    Err(_) => println!("an error occurred"),
}
```

åœ¨ä¸Šé¢çš„matchè¯­å¥ä¸­ï¼Œæˆ‘ä»¬åœ¨`Ok`åˆ†æ”¯å°†`value`ç»‘å®šè‡³å…¶å†…éƒ¨æ•°æ®ï¼Œåœ¨`Err`åˆ†æ”¯åˆ™å¿½ç•¥
äº†å…¶å†…éƒ¨æ•°æ®ã€‚

`_`å¯å‡ºç°åœ¨æ¨¡å¼ä¸­ä»»ä½•åˆ›å»ºå•ä¸ªå˜é‡ç»‘å®šçš„åœ°æ–¹ï¼Œå› æ­¤å¯ç”¨å…¶å¾ˆæ–¹ä¾¿çš„å¿½ç•¥æ‰å¤åˆç»“æ„çš„
æŸäº›æˆå‘˜ï¼š

```rust
fn coordinate() -> (i32, i32, i32) {
    // generate and return some sort of triple tuple
# (1, 2, 3)
}

let (x, _, z) = coordinate();
```

åœ¨ä¸Šé¢çš„`let`è¯­å¥ä¸­ï¼Œæˆ‘ä»¬å¿½ç•¥äº†å‡½æ•°`coordinate()`è¿”å›çš„å‘é‡çš„ç¬¬äºŒä¸ªå…ƒç´ ã€‚

éœ€è¦ç‰¹åˆ«æ³¨æ„çš„æ˜¯ä½¿ç”¨`_`ä¼šå¯¼è‡´åŒ¹é…åˆ°çš„å€¼çš„æ‰€æœ‰æƒä¸å‘ç”Ÿå˜åŒ–ï¼š

```rust
let tuple: (u32, String) = (5, String::from("five"));

// Here, tuple is moved, because the String moved:
let (x, _s) = tuple;

// The next line would give "error: use of partially moved value: `tuple`"
// println!("Tuple is: {:?}", tuple);

// However,

let tuple = (5, String::from("five"));

// Here, tuple is _not_ moved, as the String was never moved, and u32 is Copy:
let (x, _) = tuple;

// That means this works:
println!("Tuple is: {:?}", tuple);
```

ä¹‹å‰å·²ç»æè¿‡äº†ï¼Œä½ è¿˜å¯ä»¥ä½¿ç”¨`..`å¿½ç•¥å¤šä¸ªå€¼ï¼š

```rust
enum OptionalTuple {
    Value(i32, i32, i32),
    Missing,
}

let x = OptionalTuple::Value(5, -2, 3);

match x {
    OptionalTuple::Value(..) => println!("Got a tuple!"),
    OptionalTuple::Missing => println!("No such luck."),
}
```

ä»¥ä¸Šä»£ç è¾“å‡º `Got a tuple!`ã€‚

# ref and ref mut

å¦‚æœä½ å¸Œæœ›é€šè¿‡æ¨¡å¼å¾—åˆ°ä¸€ä¸ª[å¼•ç”¨][ref]ï¼Œå¯ä»¥ä½¿ç”¨`ref`å…³é”®å­—ï¼š

```rust
let x = 5;

match x {
    ref r => println!("Got a reference to {}", r),
}
```

ä»¥ä¸Šä»£ç è¾“å‡º `Got a reference to 5`.

[ref]: å¼•ç”¨å’Œå€Ÿç”¨.md

ä»¥ä¸Šä»£ç çš„matchè¡¨è¾¾å¼ä¸­çš„`r`æ˜¯ä¸€ä¸ª`&i32`ç±»å‹çš„å˜é‡ç»‘å®šã€‚æ¢å¥è¯è¯´ï¼Œ`ref`å…³é”®å­—
_åˆ›å»º_äº†ä¸€ä¸ªå¼•ç”¨ã€‚å¦‚æœä½ éœ€è¦ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œå¯ä½¿ç”¨`ref mut`ï¼š

```rust
let mut x = 5;

match x {
    ref mut mr => println!("Got a mutable reference to {}", mr),
}
```

# èŒƒå›´åŒ¹é…

å¯é€šè¿‡æ“ä½œç¬¦`...`åŒ¹é…æŒ‡å®šçš„æ•°æ®èŒƒå›´ï¼š

```rust
let x = 1;

match x {
    1 ... 5 => println!("one through five"),
    _ => println!("anything"),
}
```

ä»¥ä¸Šä»£ç è¾“å‡º`one through five`ã€‚

èŒƒå›´æ“ä½œç¬¦`...`ä¸€èˆ¬ç”¨äºæ•´æ•°å’Œ`char`ï¼š

```rust
let x = 'ğŸ’…';

match x {
    'a' ... 'j' => println!("early letter"),
    'k' ... 'z' => println!("late letter"),
    _ => println!("something else"),
}
```

ä»¥ä¸Šä»£ç è¾“å‡º`something else`ã€‚

# ç»‘å®šåŒ¹é…å€¼

ä½ å¯ä½¿ç”¨`@`å°†åŒ¹é…åˆ°çš„å€¼ç»‘å®šè‡³æŒ‡å®šå˜é‡åï¼š

```rust
let x = 1;

match x {
    e @ 1 ... 5 => println!("got a range element {}", e),
    _ => println!("anything"),
}
```

ä»¥ä¸Šä»£ç è¾“å‡º`got a range element 1`ã€‚`@`é€šå¸¸ç”¨äºè¿›è¡Œè¾ƒä¸ºå¤æ‚çš„æ‹†åˆ†æ“ä½œï¼š

```rust
#[derive(Debug)]
struct Person {
    name: Option<String>,
}

let name = "Steve".to_string();
let x: Option<Person> = Some(Person { name: Some(name) });
match x {
    Some(Person { name: ref a @ Some(_), .. }) => println!("{:?}", a),
    _ => {}
}
```

ä»¥ä¸Šä»£ç è¾“å‡º`Some("Steve")`ã€‚`a`è¢«ç»‘å®šè‡³äº†`Person`çš„`name`æˆå‘˜ã€‚

åœ¨`@`å’Œ`|`ä¸€èµ·ä½¿ç”¨çš„æƒ…å†µä¸‹ï¼Œä½ éœ€è¦ç¡®ä¿æ¯ä¸ªæ¨¡å¼éƒ½è¢«ç»‘å®šè‡³åŒä¸€ä¸ªåå­—ï¼š

```rust
let x = 5;

match x {
    e @ 1 ... 5 | e @ 8 ... 10 => println!("got a range element {}", e),
    _ => println!("anything"),
}
```

# åŒ¹é…æ¡ä»¶

å¯é€šè¿‡`if`ä¸º`match`çš„åˆ†æ”¯æ·»åŠ åŒ¹é…æ¡ä»¶ï¼š

```rust
enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    OptionalInt::Value(i) if i > 5 => println!("Got an int bigger than five!"),
    OptionalInt::Value(..) => println!("Got an int!"),
    OptionalInt::Missing => println!("No such luck."),
}
```

ä»¥ä¸Šä»£ç è¾“å‡º`Got an int!`ã€‚

åœ¨ä½¿ç”¨å¤šæ¨¡å¼`|`çš„æƒ…å†µä¸‹ï¼ŒåŒ¹é…æ¡ä»¶è¢«åº”ç”¨äºæ‰€æœ‰æ¨¡å¼ï¼š

```rust
let x = 4;
let y = false;

match x {
    4 | 5 if y => println!("yes"),
    _ => println!("no"),
}
```

ä»¥ä¸Šä»£ç è¾“å‡º`no`ï¼Œå› ä¸º`if`è¢«åº”ç”¨è‡³äº†æ•´ä¸ªæ¨¡å¼`4 | 5`ï¼Œå…¶ä¼˜å…ˆçº§å¦‚ä¸‹ï¼š

```text
(4 | 5) if y => ...
```

è€Œä¸æ˜¯ï¼š

```text
4 | (5 if y) => ...
```

# æ··åˆä½¿ç”¨

ä»¥ä¸Šä»‹ç»çš„å„ç§æ¨¡å¼åŒ¹é…æŠ€å·§å¯è¢«ç»“åˆèµ·æ¥ä½¿ç”¨ï¼Œæ¨¡å¼æ˜¯éå¸¸å¼ºå¤§çš„ï¼Œè¦ç†Ÿç»ƒä½¿ç”¨å®ƒï¼š

```rust
match x {
    Foo { x: Some(ref name), y: None } => ...
}
```
